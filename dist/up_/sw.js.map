{"mappings":"ACIA,MAAM,EAAa,oBAGb,EAAuB,CAC3B,KACA,cACA,iBACA,aACA,gBACA,uBACA,uBACA,qBACA,sBACD,CAGD,KAAK,gBAAgB,CAAC,UAAW,AAAC,IAChC,EAAM,SAAS,CACb,AAAC,CAAA,UAEC,AADc,CAAA,MAAM,OAAO,IAAI,CAAC,EAAhC,EACM,MAAM,CAAC,EACf,CAAA,IAEJ,GAGA,KAAK,gBAAgB,CAAC,WAAY,AAAC,IACjC,EAAM,SAAS,CACb,AAAC,CAAA,UACC,IAAM,EAAQ,MAAM,OAAO,IAAI,EAC/B,OAAM,QAAQ,GAAG,CACf,EAAM,GAAG,CAAC,AAAC,IACT,GAAI,IAAS,EACX,OAAO,OAAO,MAAM,CAAC,EAEzB,IAEF,MAAM,QAAQ,KAAK,EACrB,CAAA,IAEJ,GAIA,KAAK,gBAAgB,CAAC,QAAS,AAAC,IAE9B,GAAI,AAAuB,aAAvB,EAAM,OAAO,CAAC,IAAI,CAAiB,CACrC,EAAM,WAAW,CAAC,OAAO,KAAK,CAAC,MAC/B,MACF,CAGA,EAAM,WAAW,CACf,AAAC,CAAA,UACC,IAAM,EAAQ,MAAM,OAAO,IAAI,CAAC,UAEhC,AADuB,MAAM,EAAM,KAAK,CAAC,EAAM,OAAO,CAAC,GAAG,GAMnD,IAAI,SAAS,KAAM,CAAE,OAAQ,GAAI,EAC1C,CAAA,IAEJ","sources":["<anon>","sw.js"],"sourcesContent":["// The version of the cache.\nconst VERSION = \"v1\";\n// The name of the cache\nconst CACHE_NAME = `period-tracker-${VERSION}`;\n// The static resources that the app needs to function.\nconst APP_STATIC_RESOURCES = [\n    \"./\",\n    \"favicon.ico\",\n    \"src/index.html\",\n    \"src/app.js\",\n    \"src/style.css\",\n    \"src/icons/circle.ico\",\n    \"src/icons/circle.svg\",\n    \"src/icons/tire.svg\",\n    \"src/icons/wheel.svg\"\n];\n// On install, cache the static resources\nself.addEventListener(\"install\", (event)=>{\n    event.waitUntil((async ()=>{\n        const cache = await caches.open(CACHE_NAME);\n        cache.addAll(APP_STATIC_RESOURCES);\n    })());\n});\n// delete old caches on activate\nself.addEventListener(\"activate\", (event)=>{\n    event.waitUntil((async ()=>{\n        const names = await caches.keys();\n        await Promise.all(names.map((name)=>{\n            if (name !== CACHE_NAME) return caches.delete(name);\n        }));\n        await clients.claim();\n    })());\n});\n// On fetch, intercept server requests\n// and respond with cached responses instead of going to network\nself.addEventListener(\"fetch\", (event)=>{\n    // As a single page app, direct app to always go to cached home page.\n    if (event.request.mode === \"navigate\") {\n        event.respondWith(caches.match(\"/\"));\n        return;\n    }\n    // For all other requests, go to the cache first, and then the network.\n    event.respondWith((async ()=>{\n        const cache = await caches.open(CACHE_NAME);\n        const cachedResponse = await cache.match(event.request.url);\n        if (cachedResponse) // Return the cached response if it's available.\n        return cachedResponse;\n        // If resource isn't in the cache, return a 404.\n        return new Response(null, {\n            status: 404\n        });\n    })());\n}); /*\nif (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.register(\"sw.js\").then(\n      (registration) => {\n        console.log(\"Service worker registration successful:\", registration);\n      },\n      (error) => {\n        console.error(`Service worker registration failed: ${error}`);\n      },\n    );\n} else {\n    console.error(\"Service workers are not supported.\");\n}\n*/ \n\n//# sourceMappingURL=sw.js.map\n","// The version of the cache.\nconst VERSION = \"v1\";\n\n// The name of the cache\nconst CACHE_NAME = `period-tracker-${VERSION}`;\n\n// The static resources that the app needs to function.\nconst APP_STATIC_RESOURCES = [\n  \"./\",\n  \"favicon.ico\",\n  \"src/index.html\",\n  \"src/app.js\",\n  \"src/style.css\",\n  \"src/icons/circle.ico\",\n  \"src/icons/circle.svg\",\n  \"src/icons/tire.svg\",\n  \"src/icons/wheel.svg\",\n];\n\n// On install, cache the static resources\nself.addEventListener(\"install\", (event) => {\n  event.waitUntil(\n    (async () => {\n      const cache = await caches.open(CACHE_NAME);\n      cache.addAll(APP_STATIC_RESOURCES);\n    })(),\n  );\n});\n\n// delete old caches on activate\nself.addEventListener(\"activate\", (event) => {\n  event.waitUntil(\n    (async () => {\n      const names = await caches.keys();\n      await Promise.all(\n        names.map((name) => {\n          if (name !== CACHE_NAME) {\n            return caches.delete(name);\n          }\n        }),\n      );\n      await clients.claim();\n    })(),\n  );\n});\n\n// On fetch, intercept server requests\n// and respond with cached responses instead of going to network\nself.addEventListener(\"fetch\", (event) => {\n  // As a single page app, direct app to always go to cached home page.\n  if (event.request.mode === \"navigate\") {\n    event.respondWith(caches.match(\"/\"));\n    return;\n  }\n\n  // For all other requests, go to the cache first, and then the network.\n  event.respondWith(\n    (async () => {\n      const cache = await caches.open(CACHE_NAME);\n      const cachedResponse = await cache.match(event.request.url);\n      if (cachedResponse) {\n        // Return the cached response if it's available.\n        return cachedResponse;\n      }\n      // If resource isn't in the cache, return a 404.\n      return new Response(null, { status: 404 });\n    })(),\n  );\n});\n\n/*\nif (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.register(\"sw.js\").then(\n      (registration) => {\n        console.log(\"Service worker registration successful:\", registration);\n      },\n      (error) => {\n        console.error(`Service worker registration failed: ${error}`);\n      },\n    );\n} else {\n    console.error(\"Service workers are not supported.\");\n}\n*/"],"names":["CACHE_NAME","APP_STATIC_RESOURCES","self","addEventListener","event","waitUntil","cache","caches","open","addAll","names","keys","Promise","all","map","name","delete","clients","claim","request","mode","respondWith","match","url","Response","status"],"version":3,"file":"sw.js.map"}