{"mappings":"AAAA,4BAA4B;AAC5B,MAAM,UAAU;AAEhB,wBAAwB;AACxB,MAAM,aAAa,CAAC,eAAe,EAAE,QAAQ,CAAC;AAE9C,uDAAuD;AACvD,MAAM,uBAAuB;IAC3B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,yCAAyC;AACzC,KAAK,gBAAgB,CAAC,WAAW,CAAC;IAChC,MAAM,SAAS,CACb,AAAC,CAAA;QACC,MAAM,QAAQ,MAAM,OAAO,IAAI,CAAC;QAChC,MAAM,MAAM,CAAC;IACf,CAAA;AAEJ;AAEA,gCAAgC;AAChC,KAAK,gBAAgB,CAAC,YAAY,CAAC;IACjC,MAAM,SAAS,CACb,AAAC,CAAA;QACC,MAAM,QAAQ,MAAM,OAAO,IAAI;QAC/B,MAAM,QAAQ,GAAG,CACf,MAAM,GAAG,CAAC,CAAC;YACT,IAAI,SAAS,YACX,OAAO,OAAO,MAAM,CAAC;QAEzB;QAEF,MAAM,QAAQ,KAAK;IACrB,CAAA;AAEJ;AAEA,sCAAsC;AACtC,gEAAgE;AAChE,KAAK,gBAAgB,CAAC,SAAS,CAAC;IAC9B,qEAAqE;IACrE,IAAI,MAAM,OAAO,CAAC,IAAI,KAAK,YAAY;QACrC,MAAM,WAAW,CAAC,OAAO,KAAK,CAAC;QAC/B;IACF;IAEA,uEAAuE;IACvE,MAAM,WAAW,CACf,AAAC,CAAA;QACC,MAAM,QAAQ,MAAM,OAAO,IAAI,CAAC;QAChC,MAAM,iBAAiB,MAAM,MAAM,KAAK,CAAC,MAAM,OAAO,CAAC,GAAG;QAC1D,IAAI,gBACF,gDAAgD;QAChD,OAAO;QAET,gDAAgD;QAChD,OAAO,IAAI,SAAS,MAAM;YAAE,QAAQ;QAAI;IAC1C,CAAA;AAEJ,IAEA;;;;;;;;;;;;;AAaA","sources":["sw.js"],"sourcesContent":["// The version of the cache.\nconst VERSION = \"v1\";\n\n// The name of the cache\nconst CACHE_NAME = `period-tracker-${VERSION}`;\n\n// The static resources that the app needs to function.\nconst APP_STATIC_RESOURCES = [\n  \"./\",\n  \"favicon.ico\",\n  \"src/index.html\",\n  \"src/app.js\",\n  \"src/style.css\",\n  \"src/icons/circle.ico\",\n  \"src/icons/circle.svg\",\n  \"src/icons/tire.svg\",\n  \"src/icons/wheel.svg\",\n];\n\n// On install, cache the static resources\nself.addEventListener(\"install\", (event) => {\n  event.waitUntil(\n    (async () => {\n      const cache = await caches.open(CACHE_NAME);\n      cache.addAll(APP_STATIC_RESOURCES);\n    })(),\n  );\n});\n\n// delete old caches on activate\nself.addEventListener(\"activate\", (event) => {\n  event.waitUntil(\n    (async () => {\n      const names = await caches.keys();\n      await Promise.all(\n        names.map((name) => {\n          if (name !== CACHE_NAME) {\n            return caches.delete(name);\n          }\n        }),\n      );\n      await clients.claim();\n    })(),\n  );\n});\n\n// On fetch, intercept server requests\n// and respond with cached responses instead of going to network\nself.addEventListener(\"fetch\", (event) => {\n  // As a single page app, direct app to always go to cached home page.\n  if (event.request.mode === \"navigate\") {\n    event.respondWith(caches.match(\"/\"));\n    return;\n  }\n\n  // For all other requests, go to the cache first, and then the network.\n  event.respondWith(\n    (async () => {\n      const cache = await caches.open(CACHE_NAME);\n      const cachedResponse = await cache.match(event.request.url);\n      if (cachedResponse) {\n        // Return the cached response if it's available.\n        return cachedResponse;\n      }\n      // If resource isn't in the cache, return a 404.\n      return new Response(null, { status: 404 });\n    })(),\n  );\n});\n\n/*\nif (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.register(\"sw.js\").then(\n      (registration) => {\n        console.log(\"Service worker registration successful:\", registration);\n      },\n      (error) => {\n        console.error(`Service worker registration failed: ${error}`);\n      },\n    );\n} else {\n    console.error(\"Service workers are not supported.\");\n}\n*/"],"names":[],"version":3,"file":"sw.js.map","sourceRoot":"/__parcel_source_root/"}